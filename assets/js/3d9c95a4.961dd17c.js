"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[279],{9991:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var o=n(4848),i=n(8453);const t={id:"home",title:"The Basics",sidebar_position:2,sidebar_label:"The Basics"},l=void 0,a={id:"home",title:"The Basics",description:'tsk is a simple task-runner and build tool with opinions.  tsk uses TOML to describe units of work called, bear with me, "tasks". By default, your tasks live in a file named tasks.toml. A task is typically composed of one or more commands. For example:',source:"@site/docs/home.md",sourceDirName:".",slug:"/home",permalink:"/tsk-docs/docs/home",draft:!1,unlisted:!1,editUrl:"https://github.com/notnmeyer/tsk-docs/docs/home.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"home",title:"The Basics",sidebar_position:2,sidebar_label:"The Basics"},sidebar:"default",previous:{title:"Installation",permalink:"/tsk-docs/docs/installation"},next:{title:"Usage",permalink:"/tsk-docs/docs/usage"}},r={},d=[{value:"Dependencies",id:"dependencies",level:2},{value:"Dependency Groups",id:"dependency-groups",level:3},{value:"Avoiding Shell in Config Files",id:"avoiding-shell-in-config-files",level:2}];function c(e){const s={code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"tsk"})," is a simple task-runner and build tool with opinions.  ",(0,o.jsx)(s.code,{children:"tsk"}),' uses TOML to describe units of work called, bear with me, "tasks". By default, your tasks live in a file named ',(0,o.jsx)(s.code,{children:"tasks.toml"}),". A task is typically composed of one or more commands. For example:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-toml",metastring:'title="tasks.toml"',children:'[tasks.hello]\ncmds = ["echo Hello, World!"]\n'})}),"\n",(0,o.jsx)(s.p,{children:"Running this task does what you'd expect:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-shell",children:"\u279c tsk hello\nHello, World!\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Nothing Earth shattering here. What seperates ",(0,o.jsx)(s.code,{children:"tsk"})," from other tools is how it handles dependencies and how it encourages you to ",(0,o.jsx)(s.em,{children:"not"})," write extensive shell within your task definitions."]}),"\n",(0,o.jsx)(s.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,o.jsxs)(s.p,{children:["A task can include one or more task names in a ",(0,o.jsx)(s.code,{children:"deps"})," attribute. Dependencies are just regular tasks and can have deps of their own, etc."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-toml",metastring:'title="tasks.toml"',children:'[tasks.hello]\ndeps = [["sponsor"]]\ncmds = ["echo Hello, World!"]\n\n[tasks.sponsor]\ncmds = [\'echo But first a word from our sponsor!\']\n'})}),"\n",(0,o.jsxs)(s.p,{children:["Now, running ",(0,o.jsx)(s.code,{children:"hello"})," will first run ",(0,o.jsx)(s.code,{children:"sponsor"}),":"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-shell",children:"\u279c tsk hello\nBut first a word from our sponsor!\nHello, World!\n"})}),"\n",(0,o.jsx)(s.h3,{id:"dependency-groups",children:"Dependency Groups"}),"\n",(0,o.jsxs)(s.p,{children:["You may have noticed that ",(0,o.jsx)(s.code,{children:"deps"}),' is an array of arrays. Each nested array is a "dependency group". Dependency groups are one of ',(0,o.jsx)(s.code,{children:"tsk"}),"'s key features. Individual dependencies within a dependency group are exeucted in ",(0,o.jsx)(s.em,{children:"parallel"}),", while entire dependency groups are executed ",(0,o.jsx)(s.em,{children:"sequentially"}),". We can visualize this with the following example:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-toml",children:'[tasks.a]\ncmds = ["echo a"]\n\n[tasks.b]\ncmds = ["echo b"]\n\n[tasks.c]\ncmds = ["echo c"]\n\n[tasks.main]\ndeps = [\n  ["a", "b"], # a and b will run in parallel\n  ["c"],      # c will run after one and two have finished\n]\ncmds = ["echo done"]\n'})}),"\n",(0,o.jsxs)(s.p,{children:["Running ",(0,o.jsx)(s.code,{children:"main"})," we can see that task ",(0,o.jsx)(s.code,{children:"b"})," finished before ",(0,o.jsx)(s.code,{children:"a"})," and that both ran before ",(0,o.jsx)(s.code,{children:"c"}),"."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-shell",children:"\u279c tsk main\nb\na\nc\ndone\n"})}),"\n",(0,o.jsx)(s.h2,{id:"avoiding-shell-in-config-files",children:"Avoiding Shell in Config Files"}),"\n",(0,o.jsxs)(s.p,{children:["Writing shell in configuration files sucks. Luckily, tsk makes it easy to avoid. If your task doesn't include a ",(0,o.jsx)(s.code,{children:"cmds"})," attribute, tsk will look for and execute a script: ",(0,o.jsx)(s.code,{children:"tsk/<task-name>"}),". If your task is more than a few commands or needs flow control, write a script!"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-toml",metastring:'title="tasks.toml"',children:"[tasks.no-script]\n"})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-shell",children:"\u279c tsk --list --filter no-script\n[no-script]\n  # will run `tsk/no-script.sh`\n"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>a});var o=n(6540);const i={},t=o.createContext(i);function l(e){const s=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(t.Provider,{value:s},e.children)}}}]);